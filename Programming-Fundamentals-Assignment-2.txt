Question 01

Statically Typed Language
	A statically typed language is a programming language in which the data types of variables are known and checked at compile time, before the program is executed. This means that variables must be explicitly declared with their data types, and the compiler enforces type safety by ensuring that operations and assignments are performed only on compatible data types. If there is a type mismatch, the compiler generates an error, preventing many potential runtime errors. Statically typed languages offer better performance and can catch certain bugs early in the development process, but they often require more explicit type annotations compared to dynamically typed languages. Examples of statically typed languages include Java, C++, and Swift.
	
Dynamically Typed Language 
	A dynamically typed language is a programming language in which the data types of variables are determined at runtime, during program execution. Unlike statically typed languages, there is no need to explicitly declare variable types; the type of a variable is automatically inferred based on the value it holds. This flexibility allows for more concise code and rapid development but can lead to potential type-related errors during runtime if not handled properly. Dynamically typed languages include Python and JavaScript.	
	
Strongly Typed Language 
	A strongly typed language is a programming language that enforces strict type checking, ensuring that variables and expressions are used only in ways that are compatible with their declared data types. In a strongly typed language, the compiler or interpreter actively checks and enforces type rules, preventing certain type-related errors during compilation or runtime. This approach promotes safety and reliability, as it reduces the risk of unexpected behaviors due to type conversions or mismatched data types. Examples of strongly typed languages are Java and C#.	
	
Loosely Typed Language 
	A loosely typed language is a programming language that allows for more flexible handling of data types. In contrast to strongly typed languages, loosely typed languages do not enforce strict type checking, and variables can change their data type dynamically during program execution without explicit type declarations. This flexibility can lead to concise and expressive code, but it also increases the risk of type-related errors and may require additional effort to ensure data consistency and safety. Examples of loosely typed languages include JavaScript and PHP.	
	
	
Question 02

Case Sensitive:
    A programming language is considered case sensitive when it distinguishes between uppercase and lowercase characters in identifiers (such as variable names, function names, and keywords). This means that 'Hello' and 'hello' are treated as two different identifiers, and the language would recognize them as separate entities.
	Ex (Java):  int myVariable = 10; and int MyVariable = 20; are two different variables due to case sensitivity.

Case Insensitive:
    A programming language is considered case insensitive when it does not differentiate between uppercase and lowercase characters in identifiers. In this case, 'Hello' and 'hello' would be treated as the same identifier, and the language would treat them interchangeably.
	Ex (SQL): SELECT * FROM myTable; and select * from MyTable; are SQL statements are equivalent due to case insensitivity.

Case Sensitive-Insensitive:
    Some programming languages can be a combination of case sensitive and case insensitive. For example, variable names might be case sensitive, while keywords (reserved words) are case insensitive.

Regarding Java, it is a case-sensitive programming language. Java distinguishes between uppercase and lowercase characters in identifiers, making 'Hello' and 'hello' two distinct identifiers in Java. This means you need to be consistent with the capitalization when using variable names, class names, method names, and other identifiers in your Java code.


Question 03

In Java, an identity conversion is a type conversion that requires no actual conversion at all. It is the most straightforward form of type compatibility, where a value can be assigned to a variable or passed to a method without any modification because the source and target types are the same. The Java compiler performs identity conversions implicitly, ensuring type safety without the need for explicit casting.

ex 1:
public class IdentityConversionEx1 {
    public static void main(String[] args) {
        int x = 42;
        int y = x; 
        
        System.out.println("x: " + x); 
        System.out.println("y: " + y); 
             
 ex2:
 public class IdentityConversionEx2 {
    public static void main(String[] args) {
        String name = "John";
        String copyOfName = name; 
                
        System.out.println("name: " + name); 
        System.out.println("copyOfName: " + copyOfName); 
 }
}


Question 04

	Primitive widening conversion in Java is an automatic type conversion that occurs when a value of a smaller data type is assigned to a variable of a larger data type. The Java compiler performs this conversion implicitly, without the need for explicit casting, to ensure that no data loss occurs during the assignment.
	
Example 1: byte to int

public class WideningConversionEx1 {
    public static void main(String[] args) {
        byte smallNumber = 10;
        int largerNumber = smallNumber; 
    }
}


Example 2: short to long

public class WideningConversionEx2 {
    public static void main(String[] args) {
        short smallValue = 1000;
        long largeValue = smallValue;
   }    
}



Question 05

In Java, the terms "run-time constant" and "compile-time constant" refer to different types of constants based on when their values are determined during the program's life cycle:

Compile-time constant:
    A compile-time constant is a constant whose value is known and can be computed by the compiler at compile time. The compiler replaces references to compile-time constants with their actual values during the compilation process, and these values are fixed and cannot change during runtime.
    
Run-time constant:
	A run-time constant is a constant whose value is determined and known only during runtime. The value of a run-time constant can be computed during program execution, and it is not known until the program runs.    


Question 06

	Implicit (Automatic) Narrowing Primitive Conversions and Explicit Narrowing Conversions (Casting) are two ways to convert data between primitive data types with a smaller range to those with a larger range. The key difference between them lies in how the conversions are performed and the involvement of the programmer in the process.

Implicit (Automatic) Narrowing Primitive Conversions:
    Implicit narrowing primitive conversions occur automatically by the Java compiler when a value of a larger data type is assigned to a variable of a smaller data type. The conversion is performed without any explicit casting, and the compiler ensures that no data loss occurs during the conversion. This conversion happens when the target data type can represent the range of values of the source data type without losing information.
    
Explicit Narrowing Conversions (Casting):
	Explicit narrowing conversions (casting) occur when a programmer explicitly converts a value of a larger data type to a variable of a smaller data type. This process involves explicitly stating the desired type through casting. The programmer must explicitly acknowledge the possibility of data loss during the conversion because the target data type may not be able to represent the full range of values of the source data type. 
	
Conditions for Implicit Narrowing Primitive Conversion:
An implicit narrowing primitive conversion can occur if the following conditions are met:

    1. The value of the source data type is within the valid range of the target data type.
    2. No precision loss occurs during the conversion.


Question 07

	The assignment of a long data type (64 bits) into a float data type (32 bits) in Java involves a type conversion known as a narrowing primitive conversion. Java allows this conversion, but it is important to understand that it may result in a loss of precision. The discrepancy arises due to the difference in how long and float data types store their values and the range they can represent. In Java, the long data type is a 64-bit signed integer, which can represent integer values in the range of approximately -9.2 quintillion to +9.2 quintillion. On the other hand, the float data type is a 32-bit single-precision floating-point number, which can represent fractional values with a much larger range but with less precision than long.

	When you assign a long value to a float variable, the compiler performs an implicit narrowing primitive conversion, which essentially truncates the long value to fit within the float's 32-bit representation. This truncation can lead to a loss of precision, particularly when the long value has significant digits beyond the 32-bit range.
